---
name: skill-creator
description: 创建有效技能的指南。当用户想要创建新技能（或更新现有技能）以扩展智能体的能力，提供专业知识、工作流或工具集成时应使用此技能。
license: 完整条款见 LICENSE.txt
---

# 技能创建器

此技能提供创建有效技能的指导。

## 关于技能

技能是模块化、自包含的包，通过提供专业知识、工作流和工具来扩展智能体的能力。可以将它们视为特定领域或任务的"操作手册"，提供任何模型都无法完全掌握的程序性知识。

### 技能提供什么

1. 专业工作流 - 特定领域的多步骤程序
2. 工具集成 - 处理特定文件格式或 API 的说明
3. 领域专业知识 - 公司特定知识、模式、业务逻辑
4. 打包资源 - 用于复杂和重复任务的脚本、参考资料和资产

## 核心原则

### 简洁是关键

上下文窗口是共享资源，技能与其他所有内容共享这一空间。

**默认假设：智能体本身已经很智能。** 只添加智能体尚未拥有的上下文。审视每一条信息："智能体真的需要这个解释吗？"以及"这段话是否值得其 token 成本？"

优先使用简洁的示例而非冗长的解释。

### 设置适当的自由度

将特异性水平与任务的脆弱性和可变性相匹配：

**高自由度（基于文本的指令）**：当多种方法都有效、决策取决于上下文或启发式方法指导方法时使用。

**中等自由度（伪代码或带参数的脚本）**：当存在首选模式、某些变化可接受或配置影响行为时使用。

**低自由度（特定脚本、少量参数）**：当操作脆弱且容易出错、一致性至关重要或必须遵循特定顺序时使用。

把智能体想象成在探索路径：狭窄的桥梁需要特定护栏（低自由度），而开阔的田野允许许多路线（高自由度）。

### 技能的结构

每个技能由必需的 SKILL.md 文件和可选的打包资源组成：

```
skill-name/
├── SKILL.md（必需）
│   ├── YAML 前置元数据（必需）
│   │   ├── name:（必需）
│   │   ├── description:（必需）
│   │   └── compatibility:（可选，很少需要）
│   └── Markdown 指令（必需）
└── 打包资源（可选）
    ├── scripts/          - 可执行代码（Python/Bash 等）
    ├── references/       - 旨在根据需要加载到上下文中的文档
    └── assets/           - 输出中使用的文件（模板、图标、字体等）
```

#### SKILL.md（必需）

每个 SKILL.md 由前置元数据和主体组成：

- **前置元数据**：只有 `name` 和 `description` 被智能体读取以确定技能何时触发，因此要清楚全面地说明技能是什么以及何时应使用它。
- **主体**：使用技能的说明和指导，仅在技能触发后加载。

#### 打包资源（可选）

##### 脚本（`scripts/`）

可执行代码（Python/Bash 等），用于需要确定性可靠性或被重复重写的任务。

- **示例**：`scripts/rotate_pdf.py` 用于 PDF 旋转
- **好处**：节省 token、确定性、可在不加载到上下文的情况下执行
- **注意**：可能仍需要被智能体读取以进行修补或环境特定调整

##### 参考资料（`references/`）

文档和参考材料，根据需要加载到上下文中。

- **示例**：`references/finance.md`（金融模式）、`references/policies.md`（公司政策）、`references/api_docs.md`（API 规范）
- **好处**：保持 SKILL.md 精简，仅在需要时加载
- **最佳实践**：如果文件很大（>10k 字），在 SKILL.md 中包含 grep 搜索模式
- **避免重复**：信息应存在于 SKILL.md 或参考文件中，而不是两者都有。优先将详细信息放在参考文件中。

##### 资产（`assets/`）

输出中使用的文件，不加载到上下文中。

- **示例**：`assets/logo.png`（品牌资产）、`assets/slides.pptx`（PPT 模板）、`assets/frontend-template/`（HTML/React 样板）
- **好处**：将输出资源与文档分离，智能体可直接使用文件而不加载到上下文

#### 技能中不应包含什么

技能应仅包含直接支持其功能的必要文件。不要创建额外的文档或辅助文件，包括：

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md

创建额外的文档文件只会徒增混乱和困惑。

### 渐进式披露设计原则

技能使用三级加载系统来有效管理上下文：

1. **元数据（name + description）** - 始终在上下文中（~100 字）
2. **SKILL.md 主体** - 当技能触发时（<5k 字）
3. **打包资源** - 根据智能体需要（无限制，因为脚本可以在不读入上下文窗口的情况下执行）

#### 渐进式披露模式

将 SKILL.md 主体控制在必要范围内，少于 500 行以减少上下文占用。当接近此限制时，将内容拆分为单独的文件，并从 SKILL.md 引用它们。

**关键原则：** 当技能支持多种变体、框架或选项时，在 SKILL.md 中仅保留核心工作流和选择指导。将变体特定的详细信息（模式、示例、配置）移至单独的参考文件。

**模式 1：带参考的高级指南**

```markdown
# PDF 处理

## 快速开始

使用 pdfplumber 提取文本：
[代码示例]

## 高级功能

- **表单填写**：参见 [FORMS.md](FORMS.md) 获取完整指南
- **API 参考**：参见 [REFERENCE.md](REFERENCE.md) 获取所有方法
- **示例**：参见 [EXAMPLES.md](EXAMPLES.md) 获取常见模式
```

智能体仅在需要时加载 FORMS.md、REFERENCE.md 或 EXAMPLES.md。

**模式 2：按领域组织**

对于支持多个领域的技能，按领域组织内容以避免加载不相关的上下文：

```
bigquery-skill/
├── SKILL.md（概述和导航）
└── reference/
    ├── finance.md（收入、计费指标）
    ├── sales.md（机会、管道）
    ├── product.md（API 使用、功能）
    └── marketing.md（活动、归因）
```

当用户询问销售指标时，智能体仅读取 sales.md。

类似地，对于支持多个框架或变体的技能，按变体组织：

```
cloud-deploy/
├── SKILL.md（工作流 + 提供商选择）
└── references/
    ├── aws.md（AWS 部署模式）
    ├── gcp.md（GCP 部署模式）
    └── azure.md（Azure 部署模式）
```

当用户选择 AWS 时，智能体仅读取 aws.md。

**模式 3：条件详细信息**

显示基本内容，链接到高级内容：

```markdown
# DOCX 处理

## 创建文档

使用 docx-js 创建新文档。参见 [DOCX-JS.md](DOCX-JS.md)。

## 编辑文档

对于简单编辑，直接修改 XML。

**对于跟踪更改**：参见 [REDLINING.md](REDLINING.md)
**对于 OOXML 详细信息**：参见 [OOXML.md](OOXML.md)
```

智能体仅在用户需要这些功能时读取 REDLINING.md 或 OOXML.md。

**重要指南：**

- **避免引用层级过深** - 保持引用与 SKILL.md 一级深度。所有参考文件应直接从 SKILL.md 链接。
- **为较长的参考文件添加目录** - 对于超过 100 行的文件，在顶部包含目录，以便智能体在预览时能看到完整范围。

## 技能创建流程

技能创建涉及以下步骤：

1. 理解技能需求
2. 规划可重用技能内容（脚本、参考、资产）
3. 初始化技能（运行 init_skill.py）
4. 编辑技能（实现资源并编写 SKILL.md）
5. 质量检查（文本内容、信息冗余度、核心原则、格式）
6. 打包技能（运行 package_skill.py）
7. 基于实际使用迭代

按顺序遵循这些步骤，仅在有明确理由不适用时才跳过。

### 步骤 1：通过具体示例理解技能

仅当技能的使用模式已经清晰理解时才跳过此步骤。

通过提问理解技能的使用场景。示例问题：

- "这个技能应支持什么功能？"
- "您能给出一些使用示例吗？"
- "用户会说什么来触发此技能？"

避免在单条消息中提出太多问题，从最重要的问题开始跟进。

#### 解决疑惑

当存在不确定或模糊之处时，以对话方式提出 2-3 种选项：

1. 首先提出推荐的选项并解释原因
2. 说明其他选项的权衡
3. 让用户选择

示例：

> "关于文件输出格式，我建议默认使用 JSON（推荐），因为它易于解析且兼容性好。另外两个选项是：YAML（更易读但解析较慢）或 TOML（配置文件常用）。您倾向于哪种格式？"

当对技能应支持的功能有清晰认识时，结束此步骤。

### 步骤 2：规划可重用技能内容

分析每个示例，识别在重复执行这些工作流时有用的脚本、参考和资产。

示例：在构建 `pdf-editor` 技能以处理"帮我旋转此 PDF"等查询时，分析显示：

1. 旋转 PDF 需要每次重写相同的代码
2. 在技能中存储 `scripts/rotate_pdf.py` 脚本会有帮助

示例：在设计 `frontend-webapp-builder` 技能以处理"为我构建一个待办事项应用"等查询时，分析显示：

1. 编写前端 web 应用每次需要相同的样板 HTML/React
2. 在技能中存储包含样板 HTML/React 项目文件的 `assets/hello-world/` 模板会有帮助

示例：在构建 `big-query` 技能以处理"今天有多少用户登录？"等查询时，分析显示：

1. 查询 BigQuery 需要每次重新发现表模式和关系
2. 在技能中存储记录表模式的 `references/schema.md` 文件会有帮助

### 步骤 3：初始化技能

当从头开始创建新技能时，始终运行 `init_skill.py` 脚本。该脚本能够方便地生成一个新的模板技能目录，自动包含技能所需的一切。

用法：

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

该脚本：

- 在指定路径创建技能目录
- 生成具有正确前置元数据和 TODO 占位符的 SKILL.md 模板
- 创建示例资源目录：`scripts/`、`references/` 和 `assets/`
- 在每个目录中添加可以自定义或删除的示例文件

初始化后，根据需要自定义或删除生成的 SKILL.md 和示例文件。

### 步骤 4：编辑技能

在编辑技能时，包含对智能体有益且不明显的信息。

#### 学习经过验证的设计模式

根据技能需求查阅这些有用的指南：

- **多步骤流程**：参见 references/workflows.md 了解顺序工作流和条件逻辑
- **特定输出格式或质量标准**：参见 references/output-patterns.md 了解模板和示例模式

#### 从可重用技能内容开始

从上面识别的可重用资源开始：`scripts/`、`references/` 和 `assets/` 文件。注意此步骤可能需要用户输入。

添加的脚本必须通过实际运行来测试，以确保没有错误且输出符合预期。如果有许多类似的脚本，只需要测试代表性样本以确保它们都能工作，同时兼顾完成时间。

应删除技能不需要的任何示例文件和目录。

#### 更新 SKILL.md

**编写指南：** 始终使用祈使/不定式形式。

##### 前置元数据

使用 `name` 和 `description` 编写 YAML 前置元数据：

- `name`：技能名称
- `description`：这是技能的主要触发机制，帮助智能体理解何时使用技能。
  - 包括技能做什么以及何时使用它的特定触发器/上下文。
  - 在此处包含所有"何时使用"信息，因为主体仅在触发后加载。
  - 示例："提供全面的文档创建、编辑和分析功能。当智能体需要处理专业文档（.docx 文件）时使用：(1) 创建新文档，(2) 修改或编辑内容，(3) 处理跟踪更改，(4) 添加评论"

不要在 YAML 前置元数据中包含任何其他字段。

##### 主体

编写使用技能及其打包资源的说明。

### 步骤 5：质量检查

在打包之前，必须对技能进行全面的质量检查。

#### 文本内容检查

- **准确性**：所有技术术语、API 名称、命令是否准确无误
- **完整性**：是否包含所有必要的说明和示例
- **清晰性**：描述是否清晰，避免歧义表达
- **一致性**：术语使用是否前后一致

#### 信息冗余度检查

- **重复内容**：是否存在重复的概念说明
- **过度解释**：是否对简单概念进行了过度解释
- **冗长示例**：示例是否过长或过多
- **冗余说明**：是否存在不必要的说明文字

#### 核心原则检查

- **简洁性**：是否符合"简洁是关键"原则
- **上下文占用**：是否合理控制了上下文占用
- **自由度设置**：是否设置了适当的自由度
- **渐进式披露**：是否正确应用了渐进式披露原则

#### 格式检查

- **Markdown 格式**：标题层级是否正确，列表格式是否规范
- **代码块**：代码示例是否正确标注语言类型
- **链接**：所有链接是否有效且指向正确位置
- **文件引用**：引用的文件是否存在

**重要：** 只有通过所有检查项后，才能进入打包步骤。

### 步骤 6：打包技能

技能开发完成后，必须将其打包为可分发的 .skill 文件。

```bash
scripts/package_skill.py <path/to/skill-folder>
```

可选的输出目录规范：

```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

打包脚本将：

1. **验证**技能，检查：前置元数据、命名约定、描述质量、文件组织
2. **打包**技能（如果验证通过），创建以技能命名的 .skill 文件（例如 `my-skill.skill`）。.skill 文件是以 .skill 为扩展名的 zip 文件。

如果验证失败，脚本将报告错误并退出而不创建包。修复所有验证错误后再次运行打包命令。

### 步骤 7：迭代

测试技能后，用户可能会请求改进。这通常在使用技能后立即发生，对技能表现有新鲜的上下文。

**迭代工作流：**

1. 在实际任务中使用技能
2. 注意困难或低效之处
3. 识别应如何更新 SKILL.md 或打包资源
4. 实施更改并再次测试
