# libs - 核心基础库目录

## 目录定位
存放项目的基础技术设施，提供 ECS 框架、工具库和依赖注入等底层能力。

## 架构分层

```
┌─────────────────────────────────────────────────────────┐
│                    业务模块 (business-modules)            │
├─────────────────────────────────────────────────────────┤
│  lko-ecs-serialization  │  ECS 实体序列化（可选扩展层）   │
├─────────────────────────┼───────────────────────────────┤
│  lko-ecs                │  ECS 框架核心（核心逻辑层）     │
├─────────────────────────┼───────────────────────────────┤
│  lko-di                 │  依赖注入（服务层）             │
├─────────────────────────┼───────────────────────────────┤
│  lko-core               │  基础工具库（基础设施层）       │
└─────────────────────────┴───────────────────────────────┘
```

## 模块职责与区分

### 基础设施层

| 模块 | 职责 | 依赖 | 性能要求 |
|------|------|------|----------|
| **lko-core** | 高性能集合、位运算工具 | 无 | 极致性能，零分配 |

### 服务层

| 模块 | 职责 | 依赖 | 设计原则 |
|------|------|------|----------|
| **lko-di** | 依赖注入容器 | lko-core | 轻量级，作用域管理 |

### 核心逻辑层

| 模块 | 职责 | 依赖 | 设计要求 |
|------|------|------|----------|
| **lko-ecs** | ECS 框架核心 | lko-core, lko-di | 95%+ 覆盖率，类型安全 |

### 可选扩展层

| 模块 | 职责 | 依赖 | 使用场景 |
|------|------|------|----------|
| **lko-ecs-serialization** | 实体序列化 | lko-ecs | 存档、网络同步 |

## 关键设计原则

1. **零依赖**: lko-core 严禁引入任何外部依赖
2. **分层依赖**: 上层模块可依赖下层，禁止反向依赖
3. **性能优先**: 核心模块（lko-core, lko-ecs）追求极致性能
4. **平台无关**: 所有模块支持 KMP 多平台（JVM、Android、JS、Wasm）

## 子模块索引

- [lko-core](./lko-core/AGENTS.md): 基础工具库
- [lko-di](./lko-di/AGENTS.md): 依赖注入框架
- [lko-ecs](./lko-ecs/AGENTS.md): ECS 框架核心
- [lko-ecs-serialization](./lko-ecs-serialization/AGENTS.md): ECS 序列化支持

## 分模块强制规则

### 何时需要拆分模块

#### 功能独立性判断
当新增功能满足以下条件时，应考虑拆分为独立模块：
1. **独立的职责边界**：功能有明确的职责范围，不与其他模块职责重叠
2. **独立的依赖关系**：有独特的依赖需求，不应污染其他模块
3. **独立的演进路径**：功能会独立演进，版本节奏与其他模块不同
4. **独立的复用价值**：功能可能被其他项目或模块复用

#### 拆分决策检查清单
- [ ] 该功能是否有清晰的职责边界？
- [ ] 该功能是否需要独立的依赖管理？
- [ ] 该功能是否会独立演进和版本化？
- [ ] 该功能是否有复用价值？
- [ ] 拆分后是否会增加不必要的复杂性？

**决策原则**：如果上述检查清单中有 3 个或以上为"是"，则应拆分为独立模块。

### 模块分层原则

#### 分层依赖规则
```
┌─────────────────────────────────────────────────────────┐
│  可选扩展层  →  可依赖核心逻辑层、服务层、基础设施层      │
├─────────────────────────────────────────────────────────┤
│  核心逻辑层  →  可依赖服务层、基础设施层                 │
├─────────────────────────────────────────────────────────┤
│  服务层      →  可依赖基础设施层                         │
├─────────────────────────────────────────────────────────┤
│  基础设施层  →  无依赖                                   │
└─────────────────────────────────────────────────────────┘
```

**强制规则**：
- 上层模块可依赖下层模块
- 禁止反向依赖（下层模块不得依赖上层模块）
- 同层模块之间禁止相互依赖
- 跨层依赖必须通过接口抽象

#### 模块粒度控制

**过粗的模块特征**（需要拆分）：
- 单个模块承担多个不相关的职责
- 模块依赖关系复杂，难以理清
- 模块变更频率高，影响范围大
- 模块代码量大，编译时间长

**过细的模块特征**（需要合并）：
- 模块之间频繁交互，耦合度高
- 模块职责过于单一，缺乏独立性
- 模块依赖关系过于复杂
- 增加了不必要的复杂性

### 模块命名规范

#### 命名格式
- **基础模块**：`lko-{功能名}`（如 lko-core, lko-di, lko-ecs）
- **扩展模块**：`lko-{核心模块}-{扩展功能}`（如 lko-ecs-serialization）

#### 命名原则
1. **简洁明了**：名称应清晰表达模块职责
2. **避免缩写**：除非是广泛认知的缩写（如 ECS, DI）
3. **层次体现**：名称应体现模块所在层次
4. **一致性**：同类模块应使用一致的命名风格

### Code Review 检查要点

#### 模块拆分合理性检查
- [ ] 新模块是否有明确的职责边界？
- [ ] 新模块的依赖关系是否合理？
- [ ] 新模块的粒度是否适当？
- [ ] 新模块的命名是否规范？

#### 分层依赖检查
- [ ] 是否遵循分层依赖原则？
- [ ] 是否存在反向依赖？
- [ ] 同层模块是否相互依赖？
- [ ] 跨层依赖是否通过接口抽象？

#### 模块边界检查
- [ ] 模块职责是否清晰？
- [ ] 模块之间是否通过接口通信？
- [ ] 模块内部实现是否对外隐藏？
- [ ] 模块变更是否影响其他模块？

## AI 开发指引

- **禁止修改**: 非架构级需求不得修改 lko-ecs 核心接口
- **测试强制**: lko-ecs 变更必须保持 95%+ 测试覆盖率
- **性能意识**: 核心循环代码必须考虑内存分配和 GC 影响
- **文档同步**: 修改架构必须同步更新本文件和代码地图
- **模块拆分**: 新增模块必须遵循分模块强制规则
